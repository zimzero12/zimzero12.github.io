<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Pen</title>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <style>
        :root {
            --background-dark: #1e1e1e;
            --background-medium: #252526;
            --background-light: #333333;
            --accent-blue: #00aaff;
            --text-primary: #f0f0f0;
        }
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--background-dark);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        header {
            width: 100%;
            text-align: center;
            padding: 1rem;
            background-color: var(--background-medium);
            border-bottom: 1px solid var(--background-light);
            flex-shrink: 0;
        }
        header h1 {
            font-size: 1.5rem;
            color: var(--accent-blue);
        }
        #app-container {
            display: flex;
            flex-grow: 1;
            width: 100%;
            height: calc(100vh - 65px);
        }
        #blockly-container {
            width: 60%;
            height: 100%;
            position: relative;
        }
        #blocklyDiv {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        #output-container {
            width: 40%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: var(--background-medium);
            border-left: 1px solid var(--background-light);
        }
        #button-bar {
            display: flex;
            padding: 0.5rem;
            background-color: var(--background-dark);
            border-bottom: 1px solid var(--background-light);
            flex-shrink: 0;
        }
        #button-bar button {
            flex-grow: 1;
            padding: 0.75rem 0;
            border: 1px solid var(--accent-blue);
            border-radius: 5px;
            background-color: transparent;
            color: var(--accent-blue);
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            margin: 0 0.5rem;
        }
        #button-bar button:hover {
            background-color: var(--accent-blue);
            color: var(--background-dark);
        }
        #runBtn {
            background-color: var(--accent-blue);
            color: var(--background-dark);
        }
        #tabs {
            display: flex;
            flex-shrink: 0;
        }
        .tab-button {
            padding: 0.75rem;
            width: 50%;
            text-align: center;
            cursor: pointer;
            background-color: var(--background-dark);
            border: none;
            color: var(--text-primary);
            border-bottom: 3px solid transparent;
            transition: border-color 0.2s, color 0.2s;
        }
        .tab-button.active {
            border-bottom-color: var(--accent-blue);
            color: var(--accent-blue);
        }
        .tab-content {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }
        #canvas-wrapper,
        #code-editor-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 1rem;
            display: none;
        }
        #canvas-wrapper.active,
        #code-editor-wrapper.active {
            display: block;
        }
        #drawingCanvas {
            width: 100%;
            height: 100%;
            border-radius: 5px;
            background-color: #ffffff;
        }
        #code-editor {
            width: 100%;
            height: 100%;
            background-color: var(--background-dark);
            color: var(--text-primary);
            border: 1px solid var(--background-light);
            border-radius: 5px;
            padding: 1rem;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1rem;
            resize: none;
        }
        @media (max-width: 800px) {
            #app-container {
                flex-direction: column;
            }
            #blockly-container,
            #output-container {
                width: 100%;
                height: 50%;
            }
            #output-container {
                border-left: none;
                border-top: 1px solid var(--background-light);
            }
        }
    </style>
</head>
<body>

    <header><h1>Pixel Pen</h1></header>
    
    <div id="app-container">
        <div id="blockly-container">
            <div id="blocklyDiv"></div>
        </div>
        <div id="output-container">
            <div id="button-bar">
                <button id="runBtn" onclick="runCode()">â–¶ Run</button>
                <button id="saveBtn" onclick="saveDrawing()">ðŸ’¾ Save</button>
                <button id="shareBtn" onclick="shareProgram()">ðŸ”— Share</button>
            </div>
            <div id="tabs">
                <button id="canvas-tab" class="tab-button active" onclick="showTab('canvas')">Canvas</button>
                <button id="code-tab" class="tab-button" onclick="showTab('code')">Code</button>
            </div>
            <div class="tab-content">
                <div id="canvas-wrapper" class="active"><canvas id="drawingCanvas"></canvas></div>
                <div id="code-editor-wrapper"><textarea id="code-editor"></textarea></div>
            </div>
        </div>
    </div>
    
    <xml id="toolbox" style="display: none">
        <category name="Events" colour="#FFD500"><block type="event_when_key_pressed"></block></category>
        <category name="Control" colour="#5C81A6"><block type="loop_block"><value name="TIMES"><shadow type="math_number"><field name="NUM">10</field></shadow></value></block></category>
        <category name="Pen Actions" colour="#5CA65C"><block type="pen_draw"></block><block type="pen_turn"></block></category>
        <category name="Pen Style" colour="#A65C81"><block type="pen_lift_drop"></block><block type="pen_color"></block><block type="pen_stroke"></block></category>
        <category name="Variables" colour="#5C5CA6" custom="VARIABLE"></category>
        <category name="Values" colour="#5C5CA6"><block type="math_number"><field name="NUM">10</field></block><block type="math_change"><value name="DELTA"><shadow type="math_number"><field name="NUM">1</field></shadow></value></block></category>
        <category name="My Tools" colour="#BF8052" custom="PROCEDURE"></category>
    </xml>

    <script>
        // =================================================================
        // PART 0: THEME AND UI LOGIC
        // =================================================================
        const DarkTheme = Blockly.Theme.defineTheme('dark', {
            'base': Blockly.Themes.Classic,
            'componentStyles': {
                'workspaceBackgroundColour': '#252526',
                'toolboxBackgroundColour': '#1e1e1e',
                'toolboxForegroundColour': '#f0f0f0',
                'flyoutBackgroundColour': '#252526',
                'flyoutForegroundColour': '#dcdcdc',
                'scrollbarColour': '#3e3e3e',
            },
        });
        
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const codeWrapper = document.getElementById('code-editor-wrapper');
        const canvasTab = document.getElementById('canvas-tab');
        const codeTab = document.getElementById('code-tab');

        function showTab(tabName) {
            const isCanvas = (tabName === 'canvas');
            canvasWrapper.classList.toggle('active', isCanvas);
            codeWrapper.classList.toggle('active', !isCanvas);
            canvasTab.classList.toggle('active', isCanvas);
            codeTab.classList.toggle('active', !isCanvas);
            if (isCanvas) {
                resizeCanvas();
            }
        }
        
        const canvas = document.getElementById('drawingCanvas');

        function resizeCanvas() {
            setTimeout(function() {
                const rect = canvas.parentElement.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                }
            }, 0);
        }

        window.addEventListener('resize', resizeCanvas);

        // =================================================================
        // PART 1: BLOCKLY SETUP
        // =================================================================
        
        Blockly.Blocks['event_when_key_pressed'] = {
            init: function() { this.appendDummyInput().appendField("when").appendField(new Blockly.FieldDropdown([["up arrow","ArrowUp"],["down arrow","ArrowDown"],["left arrow","ArrowLeft"],["right arrow","ArrowRight"],["space","Space"]]), "KEY").appendField("key pressed"); this.setNextStatement(true, null); this.setColour(35); }
        };
        Blockly.Blocks['loop_block'] = {
            init: function() { this.appendValueInput("TIMES").setCheck("Number").appendField("loop"); this.appendStatementInput("DO").setCheck(null); this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(210); }
        };
        Blockly.Blocks['pen_draw'] = {
            init: function() { this.appendValueInput("VALUE").setCheck("Number").appendField("draw"); this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(120); }
        };
        Blockly.Blocks['pen_turn'] = {
            init: function() { this.appendValueInput("VALUE").setCheck("Number").appendField("turn"); this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(120); }
        };
        Blockly.Blocks['pen_lift_drop'] = {
            init: function() { this.appendDummyInput().appendField(new Blockly.FieldDropdown([["drop","DROP"],["lift","LIFT"]]), "STATE").appendField("pen"); this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(290); }
        };
        Blockly.Blocks['pen_color'] = {
            init: function() { this.appendDummyInput().appendField("color").appendField(new Blockly.FieldDropdown([["red","red"],["blue","blue"],["green","green"],["yellow","yellow"],["black","black"],["white","white"]]), "COLOR"); this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(290); }
        };
        Blockly.Blocks['pen_stroke'] = {
            init: function() { this.appendValueInput("WIDTH").setCheck("Number").appendField("stroke"); this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(290); }
        };
        const PixelPen = new Blockly.Generator('PixelPen');
        PixelPen.forBlock['variables_set'] = function(b) { const n=b.getFieldValue('VAR'); const v=PixelPen.valueToCode(b,'VALUE',0)||'0'; return `set ${n} ${v}\n`; };
        PixelPen.forBlock['math_change'] = function(b) { const n=b.getFieldValue('VAR'); const v=PixelPen.valueToCode(b,'DELTA',0)||'0'; return `change ${n} ${v}\n`; };
        PixelPen.forBlock['variables_get'] = function(b) { return [`var(${b.getFieldValue('VAR')})`, 0]; };
        PixelPen.forBlock['event_when_key_pressed'] = function(b) { const k=b.getFieldValue('KEY'); const c=PixelPen.statementToCode(b, 'STACK'); return `when ${k}\n${c}end_when\n`; };
        PixelPen.forBlock['loop_block'] = function(b) { const r=PixelPen.valueToCode(b,'TIMES',0)||'0'; const d=PixelPen.statementToCode(b,'DO'); return `loop ${r}\n${d}end_loop\n`; };
        PixelPen.forBlock['pen_draw'] = function(b) { const v=PixelPen.valueToCode(b,'VALUE',0)||'0'; return `draw ${v}\n`; };
        PixelPen.forBlock['pen_turn'] = function(b) { const v=PixelPen.valueToCode(b,'VALUE',0)||'0'; return `turn ${v}\n`; };
        PixelPen.forBlock['math_number'] = function(b) { return [String(b.getFieldValue('NUM')), 0]; };
        PixelPen.forBlock['pen_lift_drop'] = function(b) { return b.getFieldValue('STATE')==='LIFT' ? 'lift\n' : 'drop\n'; };
        PixelPen.forBlock['pen_color'] = function(b) { return `color ${b.getFieldValue('COLOR')}\n`; };
        PixelPen.forBlock['pen_stroke'] = function(b) { const w=PixelPen.valueToCode(b,'WIDTH',0)||'1'; return `stroke ${w}\n`; };
        PixelPen.forBlock['procedures_defnoreturn'] = function(b) { const f=b.getFieldValue('NAME'); const c=PixelPen.statementToCode(b, 'STACK'); return `tool ${f}\n${c}end_tool\n`; };
        PixelPen.forBlock['procedures_callnoreturn'] = function(b) { return `use ${b.getFieldValue('NAME')}\n`; };
        PixelPen.scrub_ = function(b,c){const next = b.nextConnection && b.nextConnection.targetBlock(); return c + PixelPen.blockToCode(next);};
        
        const workspace = Blockly.inject('blocklyDiv', { toolbox: document.getElementById('toolbox'), theme: DarkTheme });
        
        workspace.addChangeListener(e => {
            document.getElementById('code-editor').value = PixelPen.workspaceToCode(workspace);
        });

        // =================================================================
        // PART 2: THE PEN OBJECT
        // =================================================================
        
        const pen = {
            x: 0, y: 0, angle: 0, isDown: true,
            reset: function() {
                resizeCanvas();
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.angle = -90;
                this.isDown = true;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = "black";
                ctx.lineWidth = 2;
                ctx.lineCap = "round";
            },
            draw: function(distance) {
                const startX = this.x, startY = this.y;
                const rad = this.angle * (Math.PI / 180);
                this.x += Math.cos(rad) * distance;
                this.y += Math.sin(rad) * distance;
                if (this.isDown) { ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(this.x, this.y); ctx.stroke(); }
            },
            turn: function(degrees) { this.angle += degrees; }
        };
        
        // =================================================================
        // PART 3: THE INTERPRETER ENGINE
        // =================================================================

        let registeredEvents = {};
        let variables = {};
        
        function runCode() {
            pen.reset();
            variables = {};
            for (const key in registeredEvents) { document.removeEventListener('keydown', registeredEvents[key]); }
            registeredEvents = {};

            const code = document.getElementById('code-editor').value;
            const allLines = code.split('\n');
            const functions = {};
            let mainProgram = [];
            
            let isParsingFunction = false, isParsingEvent = false;
            let currentName = null, currentBody = [];

            for (const line of allLines) {
                const trimmed = line.trim();
                const parts = trimmed.split(/\s+/); // Use regex to split robustly
                const command = parts[0];

                if (command === 'tool' || command === 'when') {
                    isParsingFunction = (command === 'tool');
                    isParsingEvent = (command === 'when');
                    currentName = parts[1];
                    currentBody = [];
                } else if (command === 'end_tool' || command === 'end_when') {
                    if (isParsingFunction) functions[currentName] = currentBody;
                    if (isParsingEvent) registerKeyEvent(currentName, currentBody);
                    isParsingFunction = false; isParsingEvent = false; currentName = null;
                } else if (isParsingFunction || isParsingEvent) {
                    if (trimmed) currentBody.push(trimmed);
                } else {
                    if (trimmed) mainProgram.push(trimmed);
                }
            }
            execute(mainProgram);
        }

        function resolveValue(rawValue) {
            const trimmedValue = String(rawValue).trim();
            if (trimmedValue.startsWith('var(')) {
                const varName = trimmedValue.slice(4, -1);
                return variables[varName] || 0;
            }
            return parseInt(trimmedValue) || 0;
        }

        function execute(lines) {
            for (let i = 0; i < lines.length; i++) {
                const parts = lines[i].trim().split(/\s+/);
                const command = parts[0];
                if (command === 'draw') pen.draw(resolveValue(parts[1]));
                else if (command === 'turn') pen.turn(resolveValue(parts[1]));
                else if (command === 'lift') pen.isDown = false;
                else if (command === 'drop') pen.isDown = true;
                else if (command === 'color') ctx.strokeStyle = parts[1];
                else if (command === 'stroke') ctx.lineWidth = resolveValue(parts[1]);
                else if (command === 'set') { variables[parts[1]] = resolveValue(parts[2]); }
                else if (command === 'change') { variables[parts[1]] = (variables[parts[1]] || 0) + resolveValue(parts[2]); }
                else if (command === 'use') { if (functions[parts[1]]) execute(functions[parts[1]]); }
                else if (command === 'loop') {
                    const count = resolveValue(parts[1]);
                    let body = [];
                    let level = 1;
                    let end = -1;
                    for (let j = i + 1; j < lines.length; j++) {
                        const line = lines[j].trim();
                        if (line.startsWith('loop')) level++;
                        if (line === 'end_loop') level--;
                        if (level === 0) { end = j; break; }
                    }
                    if (end !== -1) {
                        body = lines.slice(i + 1, end);
                        for (let k = 0; k < count; k++) { execute(body); }
                        i = end;
                    }
                }
            }
        }
        
        function registerKeyEvent(key, body) {
            const handler = function(event) { if (event.key === key) { event.preventDefault(); execute(body); } };
            document.addEventListener('keydown', handler);
            registeredEvents[key] = handler;
        }
        
        // =================================================================
        // PART 4: CREATOR'S TOOLKIT & ONLOAD
        // =================================================================
        
        function saveDrawing() {
            const link = document.createElement('a');
            link.download = 'pixelpen_creation.png';
            link.href = canvas.toDataURL('image/png', 1.0);
            link.click();
        }

        function shareProgram() {
            const code = PixelPen.workspaceToCode(workspace);
            const encoded = btoa(code);
            const link = `${window.location.origin}${window.location.pathname}#code=${encoded}`;
            prompt("Copy this link to share your program:", link);
        }
        
        window.onload = function() {
            if (window.location.hash.startsWith('#code=')) {
                try {
                    document.getElementById('code-editor').value = atob(window.location.hash.substring(6));
                } catch (e) { console.error("Failed to load shared code:", e); }
            }
            showTab('canvas');
            runCode();
        };
    </script>
</body>
</html>
